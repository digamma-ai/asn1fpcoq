\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usepackage{listings}

\input{listings-coq}

\title{Proving C program correct using C light operational semantics}
\date{ }

\begin{document}

\maketitle

\begin{frame}{Outline}
\begin{enumerate}
\item Formal verification - quick intro (high-level)
\item Coq mini intro 
\item Approach
\begin{itemize}   
\item Particular approach we consider: reasoning about C programs in Coq
\item Base PL concepts mini intro: syntax, AST, semantics.
\end{itemize}{}
\item Toy example: strlen Informal specification (man page)
\begin{itemize}

\item Formal specification of strlen (relational)
\item Simple implementation in C
\item From C program to AST using clightgen
\item Semantics of C program semantics and its equivalence to specification
\item Undefined behaviours in C and guarding against them
\end{itemize}{}
\item Conclusions
\end{enumerate} 
\end{frame}{}

% do the first two sections in the end, maybe ask boys
\section{Formal verification - quick intro}
\begin{frame}{Formal verification - quick intro}
 
  We want to have high assurance that our code works as intended. One of the methods is formal verification. It is a broad term that includes many techniques. Here I will talk about deductive verification. This means we want to produce a formal proof that our code works as intended. What does it mean exactly and how do we do it?
  
  \bigskip
  
   On one hand we have C implementation of some function,
   on the other hand we have our ideas about what it supposed to do -- its specification. To formally verify some function we need to:
   
  \begin{enumerate}
  \item Write it's specification in a formal language  
  \item Write the implementation in the same formal language
  \item Formalize the notion of ``meeting the specification'' (partial correctness, total correctness)
  \item Prove that your implementation meets the specification
  \end{enumerate}
\end{frame}

\begin{frame}{Coq intro}
 As a formal language we choose dependent type theory, which is a very expressive language well studied in mathematical logic. It is much more likely to make a mistake in a formal proof (which is typically way longer than the code), so we want an assurance that our proof is correct. Hence we use a proof assistant Coq: a program that checks that your proof is correct. It also provides an environment to make construction of the proofs easier. Coq's language is based on dependent type theory and is called Gallina.
  
\end{frame}
\begin{frame}{Coq intro cont'd}
  
 
  
  \end{frame}

  \begin{frame}{CompCert}
    Coq has been used to conduct some big verification projects. One of them is CompCert, a verfied compiler for C, almost entirely written in Coq and proved to work according to the specification.
        \bigskip
 To do this they formalized C syntax and semantics (C99 standard).

    \bigskip
    
    Nice thing about Coq is that writing a specification is basically the same as writing a program that meets that specification, since Gallina is a functional programming language. One can extract the code to OCaml or Haskell to compile and run it.

    
    
\end{frame}


\section{Approach}

\begin{frame}{Traditional approach}
  Illya did something similar. He wrote a part of ASN.1 compiler in Coq and proved that it works correctly. Then he extracted the code to OCaml. The extracted code performed badly (cf. Illya). Moreover, the extraction mechanism of Coq is not verified so it can introduce bugs unless restricted to ML subset of Gallina.
\end{frame}

\begin{frame}{New approach}
  We decided to try to verify the implementation of ASN1 compiler that already exists. This reduces TCB (TODO: explain) and moreover we could use the same techniques in other projects. We reuse parts of CompCert for this.
\begin{itemize}
\item parse C code into an abstract syntax tree using C light generator of CompCert (not verified)
  \item write a functional specification using CompCert's model of C light 
\item reason about the C light program using operational semantics defined in CompCert
\end{itemize}
\end{frame}
\subsection{Base PL concepts mini intro: syntax, AST, semantics.}

\begin{frame}
  Concrete vs Abstract syntax

  We write a C program in concrete C syntax, which is designed to be used by a parser (a + b).
  Abstract syntax tree: nodes are constructors, leaves are atoms (plus (a,b)).
  todo: more on AST

  Deep embedding of C light to Coq := the abstract syntax is defined as inductive datatypes
  
\end{frame}

\section{C light syntax}
\begin{frame}{Types of CompCert's C}

  Compcert C light types include numeric types,
  pointers, arrays, function types, and composite types (struct and union).  Numeric types (integers and floats) fully specify the
  bit size of the type.  An integer type is a pair of a signed/unsigned
  flag and a bit size: 8, 16, or 32 bits, or the special IBool size
  standing for the C99 Bool type.  64-bit integers are treated separately.

\end{frame}

\begin{frame}[fragile]{Types of CompCert's C}
  \begin{lstlisting}[language=Coq]
 Inductive type : Type :=
  | Tvoid: type 
  | Tint: intsize -> signedness -> attr -> type 
  | Tlong: signedness -> attr -> type 
  | Tfloat: floatsize -> attr -> type 
  | Tpointer: type -> attr -> type       
  | Tarray: type -> Z -> attr -> type              
  | Tfunction: typelist -> type -> calling_convention -> type   
  | Tstruct: ident -> attr -> type                 
  | Tunion: ident -> attr -> type                 
  with typelist : Type :=
  | Tnil: typelist
  | Tcons: type -> typelist -> typelist.

\end{lstlisting}


\end{frame}

\begin{frame}[fragile]{Types of C light}
  \begin{lstlisting}[language=Coq]
Definition tvoid := Tvoid.
Definition tschar := Tint I8 Signed noattr.
Definition tuchar := Tint I8 Unsigned noattr.
Definition tshort := Tint I16 Signed noattr.
Definition tushort := Tint I16 Unsigned noattr.
Definition tint := Tint I32 Signed noattr.
Definition tuint := Tint I32 Unsigned noattr.
Definition tbool := Tint IBool Unsigned noattr.
Definition tlong := Tlong Signed noattr.
Definition tulong := Tlong Unsigned noattr.
Definition tfloat := Tfloat F32 noattr.
Definition tdouble := Tfloat F64 noattr.
Definition tptr (t: type) := Tpointer t noattr.
Definition tarray (t: type) (sz: Z) := Tarray t sz noattr.
\end{lstlisting}


\end{frame}



\begin{frame}[fragile]{Expressions of C light}
  \begin{lstlisting}[language=Coq]
Inductive expr : Type :=
| Econst_int: int -> type -> expr  (* integer literal *)    
| Econst_float: float -> type -> expr (* double float literal *)
| Econst_single: float32 -> type -> expr (* single float *)
| Econst_long: int64 -> type -> expr (* long integer literal *)
| Evar: ident -> type -> expr (* variable *)
| Etempvar: ident -> type -> expr (* temporary variable *)
| Ederef: expr -> type -> expr (* pointer dereference (*) *)
| Eaddrof: expr -> type -> expr (* address-of operator (&) *)
| Eunop: unary_operation -> expr -> type -> expr
(* unary operation *)
| Ebinop: binary_operation -> expr -> expr -> type -> expr
(* binary operation *)
| Ecast: expr -> type -> expr   (* type cast *)
| Efield: expr -> ident -> type -> expr
(* access to a member of a struct or union *)
| Esizeof: type -> type -> expr (* size of a type *)
| Ealignof: type -> type -> expr. (* alignment of a type *)
\end{lstlisting}


\end{frame}


    

\begin{frame}[fragile]{Examples}

  \begin{lstlisting}[language=Coq]
    (* 0 *)
    (Econst_int Int.zero tint) 

    (* 0 + 1 *)
    (Ebinop Oadd (Econst_int Int.zero tint)
    (Econst_int (Int.repr 1) tint) (tint))

    (* int *p *)
    (Etempvar _p (tptr tint)) 
    
    (* (*p) *)
    (Ederef (Etempvar _p (tptr tint)) tint)


  \end{lstlisting}
  


\end{frame}


\begin{frame}

Note that in C light all expressions are {\bf pure}. Variable assignements and function calls are statements.
    
\end{frame}

\begin{frame}[fragile]{Statements}

  \begin{lstlisting}[language=Coq]
Inductive statement : Type :=
| Sskip : statement (* do nothing *)
| Sassign : expr -> expr -> statement
(* assignment lvalue = rvalue *)
| Sset : ident -> expr -> statement
(* assignment tempvar = rvalue *)
| Scall: option ident -> expr -> list expr -> statement
| Sbuiltin: option ident -> external_function -> typelist -> list expr -> statement
(* builtin invocation *)
| Ssequence : statement -> statement -> statement
| Sifthenelse : expr  -> statement -> statement -> statement
| Sloop: statement -> statement -> statement (* infinite loop *)
| Sbreak : statement
| Scontinue : statement
| Sreturn : option expr -> statement
| Sswitch : expr -> labeled_statements -> statement
| Slabel : label -> statement -> statement
| Sgoto : label -> statement

  \end{lstlisting}
  


\end{frame}



\begin{frame}[fragile]{Statements}

  \begin{lstlisting}[language=Coq]
    
Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).

  \end{lstlisting}
  


\end{frame}


\begin{frame}[fragile]{Examples}

  \begin{lstlisting}[language=Coq]
     (* int s = 1; *)
      (Sset _s (Econst_int (Int.repr 1) tint))

      (* return s; *)
      (Sreturn (Some (Etempvar _s tint)))

      (* while (s) {s = s - 1;} *)
      (Swhile (Etempvar _s tint) 
      (Ssequence  
        (Sset _s (Ebinop Osub (Etempvar _input tint)
                (Econst_int (Int.repr 1) tint) tint))))


  \end{lstlisting}
  


\end{frame}

\begin{frame}{Unsupported features}
  \begin{itemize}
  \item `extern` declaration of arrays
\item structs and unions cannot be passed by value
\item  type qualifiers (`const`, `volatile`, `restrict`) are erased at parsing
\item within expressions no side-effects nor function calls (meaning all C light expressions always terminate and are pure)
\item statements: in `for(s1, a, s2)` s1 and s2 are statements, that do not terminate by break
\item `extern` functions are only declared and not defined, used to model system calls
\end{itemize}
there are more - see p. 2-7 of Mechanized Sem. for details. (TODO)
  
  \end{frame}


  \section{Operational semantics: bigstep}

  
  \begin{frame}{Operational semantics}

    Our goal is to prove that programs written in C light behave as intented. To do this we need to formalize the notion of meaning of a C light program. We do this using what is called operational semantics. We start from assigning primitive values to constants and then compositionally assign values to expressions and statements.

   \bigskip
We evaluate a statement $s$ in a context with local variables $le$ and memory state $m$. Rules described in Fig.6-10. of Mech Sem. Here talk about CompCert's implementation.
    \end{frame}

  \begin{frame}
    A CompCert C value is either\footnote{This is a common semantics used for all intermediate languages of CompCert, such as C minor etc.}:
    \begin{itemize}
    
\item a machine integer;
\item a floating-point number;
\item a pointer: a pair of a memory address and an integer offset with respect
  to this address;
\item the \texttt{Vundef} value denoting an arbitrary bit pattern, such as the
  value of an uninitialized variable.
 \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Values}
  
\begin{lstlisting}[language=Coq]

  Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.
\end{lstlisting}

\begin{itemize}
\item \texttt{float} type is formalized in Flocq library
\item \texttt{int} and \texttt{ptrofs} types are defined in CompCert 
\end{itemize}
  
\end{frame}  


\begin{frame}[t,fragile]{Integers}

Formalizations of machine integers modulo $2^N$ defined as a module type in CompCert \url{lib/Integers.v}.\\

\bigskip

A machine integer (type \texttt{int}) is represented as a Coq arbitrary-precision
integer (type \texttt{Z} ) plus a proof that it is in the range 0 (included) to
modulus (excluded).

\bigskip

\begin{lstlisting}[language=Coq]
Record int: Type :=
mkint { intval: Z; intrange: -1 < intval < modulus }.
\end{lstlisting}

8, 32, 64-bit integers are supported, as well as 32 and 64-bit pointer offsets.

\end{frame}

\begin{frame}[t,fragile]{Integers}

 Integer is basically a natural number with a bound, thus we can prove an induction principle for integers

\bigskip

\begin{lstlisting}[language=Coq]
  Lemma int_induction :
  forall (P : int -> Prop), P Int.zero ->
       (forall i, P i -> P (Int.add i Int.one)) ->
             forall i, P i.
\end{lstlisting}

 \begin{proof}

   By using induction principle for non-negative integers \texttt{natlike\_ind} for \texttt{Z}.
                                       
 \end{proof}



\end{frame}




\begin{frame}{Memory model}
See CompCert's \url{common/Memory.v}



\bigskip
There is a type \texttt{mem} of memory states with  the following 4 basic operations over memory states, and their properties:
\begin{itemize}
\item [load]: read a memory chunk at a given address;
\item [store]: store a memory chunk at a given address;
\item [alloc]: allocate a fresh memory block;
\item [free]: invalidate a memory block.
\end{itemize}

Address is a pair $[b,ofs]$ of a memory block identifier and pointer offset (of integer type \texttt{ptrofs}), it has permissions associated to it that influence the behaviour of load and store.

\end{frame}

\begin{frame}{Local environment}
  Local environment is modelled as applicative finite maps. The two main operations
  are [set k d m], which returns a map identical to [m] except that [d]
  is associated to [k], and [get k m] which returns the data associated
  to key [k] in map [m].  In CompCert's Maps library, they distinguish two kinds of maps:
  \begin{enumerate}
\item Trees: the [get] operation returns an option type, either [None]
  if no data is associated to the key, or [Some d] otherwise.
\item Maps: the [get] operation always returns a data.  If no data was explicitly
  associated with the key, a default data provided at map initialization time
  is returned.
  \end{enumerate}
  \end{frame}

  
  \begin{frame}{C light big-step semantics}
    Now we can formalize evaluation of expressions to values and executions of statements that may modify local environment and memory states. 

  \end{frame}
  \begin{frame}{Evaluation of expressions}
    See  Clight.eval\_expr.
  \end{frame}
  \begin{frame}{Execution of statements}
    See ClightBigstep.exec\_stmt
    \end{frame}

  \begin{frame} {\huge \center Toy example: length of a C string} \end{frame}


\begin{frame}{Informal spec: strlen}


  The GNU C Reference Manual:
 \bigskip


  $\ldots$ A string constant is of type ``array of characters''. All string constants contain a null termination character as their last character.

\bigskip

$\ldots$
DESCRIPTION        

 The strlen() function calculates the length of the string pointed to
 by s, excluding the terminating null byte.

 \bigskip

RETURN VALUE 

 The strlen() function returns the number of bytes in the string
 pointed to by s.

 \bigskip

CONFORMING TO 

 POSIX.1-2001, POSIX.1-2008, C89, C99, C11, SVr4, 4.3BSD.



\end{frame}

\begin{frame}
 To formalize the spec we need a formal model of C integers, pointers and memory model
\end{frame}

\begin{frame}[t,fragile]{Formal spec}

  \begin{lstlisting}[language=Coq]
    
Inductive strlen (m : mem) (b : block) (ofs : ptrofs) : int -> Prop :=
  | LengthZero: load m [b,ofs] = Some 0 -> strlen m b ofs 0
  | LengthSucc: forall (n : int) (c : char),
                      strlen m b ofs + 1 n ->
                      load m [b,ofs] = Vint c ->
                      c <> Int.zero ->
                      n + 1 <= MaxInteger ->
                      strlen m b ofs n + 1.
  \end{lstlisting}
  
  
  
      
\end{frame}

\begin{frame}{From C program to AST using clightgen}

\lstinputlisting[language=C]{strlen.c}

\end{frame}

\begin{frame}[fragile]{C light AST (loop of strlen)}

\begin{lstlisting}[language=Coq]
Definition f_strlen_loop := {|
fn_params := ((_s, (tptr tuchar)) :: nil);
fn_temps := ((_i, tuint) :: (_t1, (tptr tuchar)) :: (_t2, tuchar) :: nil);
fn_body := 
(Sloop
(Ssequence
(Ssequence
(Ssequence
  (Sset _t1 (Etempvar _s (tptr tuchar)))
  (Sset _s
    (Ebinop Oadd (Etempvar _t1 (tptr tuchar))
      (Econst_int (Int.repr 1) tint) (tptr tuchar))))
(Ssequence
  (Sset _t2 (Ederef (Etempvar _t1 (tptr tuchar)) tuchar))
  (Sifthenelse (Etempvar _t2 tuchar) Sskip Sbreak)))
(Sset _i
(Ebinop Oadd (Etempvar _i tuint) (Econst_int (Int.repr 1)
 tint)
  tuint)))
Sskip) |}.

\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Correctness}

  We prove that for all strings our program computes correct result. In particular:
  
  \begin{theorem}
    For all addresses $[b, ofs]$ where a valid C string of length $len$ is stored, the C light AST $f\_strlen$ evaluates to $len$.
  \end{theorem}
  
  
  \begin{lstlisting}[language=Coq]
Lemma strlen_correct:
forall len m b ofs le, strlen m b ofs len -> exists t l',
  le!_input = Some (Vptr b ofs) ->
  exec_stmt le m f_strlen t le' m (Out_return (Some (Vint len))).

\end{lstlisting}

To prove this statement we have to prove that loop works correctly.

 



\end{frame}

  
\begin{frame}[fragile]{Correctness cont'd}

  
  
  \begin{lstlisting}[language=Coq]
 Lemma strlen_loop_correct: forall len m b ofs le,
 strlen m b ofs len -> exists t le',
 le!_output = Some (Vint 0) ->
 le!_input = Some (Vptr b ofs) ->
 exec_stmt ge e le m f_strlen_loop t le' m Out_normal
                     /\ le'!_output = Some (Vint len).
\end{lstlisting}

\begin{proof}
  We prove a generalization of this statement
  
 \begin{lstlisting}[language=Coq]
 Lemma strlen_loop_correct_gen : forall len m b ofs le,
 strlen m b ofs + i len -> exists t le',
 le!_output = Some (Vint i) ->
 le!_input = Some (Vptr b ofs + i) ->
 exec_stmt ge e le m f_strlen_loop t le' m Out_normal
                     /\ le'!_output = Some (Vint len + i).
\end{lstlisting}

by \texttt{int}-induction on $len$ and $i$. 

  \end{proof}

 



\end{frame}

\begin{frame}{Conclusion}
  Thus we have proved that on all strings of length smaller than
  \texttt{UINT\_MAX}, \texttt{strlen} works correctly.
  
  \end{frame}

  \begin{frame}
  
  Limitations

  Partial correctness (safety? liveness?)
  
  \end{frame}

\end{document}